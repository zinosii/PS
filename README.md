# PS
* 2022.02.04  
  + <boj 9328, 열쇠>
    * 처음 풀이 :<br> **1**. 가장자리에 위치한 빈공간을 모두찾은후, 빈 공간의 좌표를 담는 큐를 만듬.<br> **2**. 그 큐가 빌때까지 bfs. 만약 한 위치에서 탐색하며 문을 만난경우, 그 문을 열 수 없으면 다시 큐에 넣어주어야함(나중에 열쇠를 얻을수 있으므로) 여기서 시간이 많이쓰임 
    * 더 나은 풀이 :<br> **1**. h, 입력받고, 지도를 감싸는 빈공간을 생성해줌, 즉 지도의 사이즈를 (h+2) * (w+2)로 변경.<br> **2**. door queue 를 만들어서 그에 해당하는 key를 얻으면, 그 문의 위치를 다시 position queue 로 넘겨주어 (0,0)에서 시작하는 bfs한번만에 풀이가능
+ 2022.02.05 
  + <boj 9466, 텀프로젝트> 
    + 처음 풀이 :<br> **1**. 각 학생이 선택한 학생의 정보를 담는 Choice 리스트와, 각 학생의 상태를 담는 visit리스트를 만듬 visit이 -1 일경우 방문을 안한 경우, 0일 경우 팀을 못 이룬 경우, 1일 경우 팀을 이룬것.<br> **2**. 1부터 N번 까지, visit이 -1인 경우만 함수실행.<br> **3**. 함수의 인자는 학생의 번호, 지금까지 선택된 학생의 정보를 담는 리스트와 집합이있는데, 각 함수마다 학생이 선택한 학생이 팀원리스트에 있는지 확인하기 위해 set을 같이 사용함 **-> 시간복잡도를 줄여 AC를 받을수있었음.**<br> **4**. 만약 선택한 학생이 집합내에 있을경우, 리스트의 순서대로 팀을 이뤘는지 판단가능 하므로 visit 업데이트. 
    + 더 나은 풀이 :<br> **1**. 방문한 학생들의 번호를 담는 집합 team 을 만듬.<br> **2**. 각 학생마다 dfs시작, dfs시작시 바로 방문처리를 해줌.<br> **3**. 만약 선택한 학생이 방문 처리된 경우, cycle을 이루는지 확인하여 cnt를 증가시켜줌. dfs마지막에는 team집합 업데이트.
  + <boj12852, 1로 만들기 2>
    + 이 문제는 bfs와 dp 두가지로 풀수있었음.
    + dfs풀이 :<br> **1**. N을 입력받고 N으로부터 bfs시작. bfs는 숫자와 지금까지 방문한 숫자 리스트의 정보가 담김.<br> **2**. visit리스트를 만들어 방문된경우 bfs큐 에 넣어줄 필요없음. 1이 되면 종료
    + DP풀이 :<br> **1**. DP리스트와 정답의 정보를 담을 ans리스트를 만듬. DP는 최댓값으로 채워주고, DP[1]=0으로 초기화 함으로써 DP를 1부터 채워줌.<br> **2**. ans배열은 이값을 만들수있는 숫자의 정보를 담음 ex) ans[10]은 9에서 오거나 5에서 올수있음. 둘중 더 작은 DP를 갖는 9로 부터 10이 채워짐.<br> **3**. DP[N]을 출력하고 N, ans[N]에서 ans[1]로 갈때까지 while문 으로 출력해줌.
